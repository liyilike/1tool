<html xmlns="http://www.w3.org/1999/xhtml" xmlns:wb="http://open.weibo.com/wb"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0" />
	<title>JSON格式化整理缩进 - {$site.name}</title>
	 <include="/Tpl/default/Include/app_header_code.html" />
	<meta name="keywords" content="JSON格式化,JSON整理,JSON缩进" />
	<meta name="description" content="1tool第一在线工具网提供JSON格式化,JSON整理,JSON缩进,更多实用工具尽在www.1tool.org" />
<link rel="stylesheet" href="./在线任意格式图片圆角处理工具 - 在线生成透明圆角图标 - aTool在线工具_files/bijou.min.css">
<link rel="stylesheet" href="./在线任意格式图片圆角处理工具 - 在线生成透明圆角图标 - aTool在线工具_files/style.new.css">

		<meta name="Keywords" content="aTool,在线工具,图片圆角,图标圆角,圆角图标,透明圆角图标,透明圆角生成">
		<meta name="Description" content="aTool,在线工具，本工具提供一个可以轻松的将任意图片生成圆角图片的网站，并且可以指定图片的圆角大小，另外，图片的大小完全不限制。">
		<script type="text/javascript" >
		this.libcanvas = this.exports = (function () { var exports = {}; exports.createCanvasBasedOnImg = function (img) { var canvas = document.createElement('canvas'); canvas.width = img.width; canvas.height = img.height; exports.pasteImg(canvas, img); return canvas; }; exports.pasteImg = function (canvas, img) { canvas.getContext('2d').globalCompositeOperation = 'copy'; canvas.getContext('2d').drawImage(img, 0, 0); }; exports.downloadablePng = function (canvas) { return canvas.toDataURL("image/png").replace("image/png", "image/octet-stream") }; exports.downloadAsPng = function (canvas) { window.location.href = exports.downloadablePng(canvas); }; exports.roundCanvas = function (canvas, radius) { radius = radius; exports.cutRoundedRect(canvas.getContext('2d'), radius, 0, 0, canvas.width, canvas.height); }; exports.cutRoundedRect = function(ctx, radius, x, y, w, h) { var left = x; var top = y; var right = x + w; var bottom = y + h; ctx.globalCompositeOperation = 'destination-in'; ctx.fillStyle = 'black'; ctx.beginPath(); ctx.moveTo(left + radius, top); ctx.lineTo(right - radius, top); ctx.quadraticCurveTo(right, top, right, top + radius); ctx.lineTo(right, bottom - radius); ctx.quadraticCurveTo(right, bottom, right - radius, bottom); ctx.lineTo(left + radius, bottom); ctx.quadraticCurveTo(left, bottom, left, bottom - radius); ctx.lineTo(left, top + radius); ctx.quadraticCurveTo(left, top, left + radius, top); ctx.fill(); }; return exports;}());
		</script>
		<script type="text/javascript" >
		var saveAs=saveAs||function(e){"use strict";if(typeof navigator!=="undefined"&&/MSIE [1-9]\./.test(navigator.userAgent)){return}var t=e.document,n=function(){return e.URL||e.webkitURL||e},r=t.createElementNS("http://www.w3.org/1999/xhtml","a"),i="download"in r,o=function(e){var t=new MouseEvent("click");e.dispatchEvent(t)},a=/Version\/[\d\.]+.*Safari/.test(navigator.userAgent),f=e.webkitRequestFileSystem,u=e.requestFileSystem||f||e.mozRequestFileSystem,s=function(t){(e.setImmediate||e.setTimeout)(function(){throw t},0)},c="application/octet-stream",d=0,l=500,w=function(t){var r=function(){if(typeof t==="string"){n().revokeObjectURL(t)}else{t.remove()}};if(e.chrome){r()}else{setTimeout(r,l)}},p=function(e,t,n){t=[].concat(t);var r=t.length;while(r--){var i=e["on"+t[r]];if(typeof i==="function"){try{i.call(e,n||e)}catch(o){s(o)}}}},v=function(e){if(/^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(e.type)){return new Blob(["\ufeff",e],{type:e.type})}return e},y=function(t,s,l){if(!l){t=v(t)}var y=this,m=t.type,S=false,h,R,O=function(){p(y,"writestart progress write writeend".split(" "))},g=function(){if(R&&a&&typeof FileReader!=="undefined"){var r=new FileReader;r.onloadend=function(){var e=r.result;R.location.href="data:attachment/file"+e.slice(e.search(/[,;]/));y.readyState=y.DONE;O()};r.readAsDataURL(t);y.readyState=y.INIT;return}if(S||!h){h=n().createObjectURL(t)}if(R){R.location.href=h}else{var i=e.open(h,"_blank");if(i==undefined&&a){e.location.href=h}}y.readyState=y.DONE;O();w(h)},b=function(e){return function(){if(y.readyState!==y.DONE){return e.apply(this,arguments)}}},E={create:true,exclusive:false},N;y.readyState=y.INIT;if(!s){s="download"}if(i){h=n().createObjectURL(t);r.href=h;r.download=s;setTimeout(function(){o(r);O();w(h);y.readyState=y.DONE});return}if(e.chrome&&m&&m!==c){N=t.slice||t.webkitSlice;t=N.call(t,0,t.size,c);S=true}if(f&&s!=="download"){s+=".download"}if(m===c||f){R=e}if(!u){g();return}d+=t.size;u(e.TEMPORARY,d,b(function(e){e.root.getDirectory("saved",E,b(function(e){var n=function(){e.getFile(s,E,b(function(e){e.createWriter(b(function(n){n.onwriteend=function(t){R.location.href=e.toURL();y.readyState=y.DONE;p(y,"writeend",t);w(e)};n.onerror=function(){var e=n.error;if(e.code!==e.ABORT_ERR){g()}};"writestart progress write abort".split(" ").forEach(function(e){n["on"+e]=y["on"+e]});n.write(t);y.abort=function(){n.abort();y.readyState=y.DONE};y.readyState=y.WRITING}),g)}),g)};e.getFile(s,{create:false},b(function(e){e.remove();n()}),b(function(e){if(e.code===e.NOT_FOUND_ERR){n()}else{g()}}))}),g)}),g)},m=y.prototype,S=function(e,t,n){return new y(e,t,n)};if(typeof navigator!=="undefined"&&navigator.msSaveOrOpenBlob){return function(e,t,n){if(!n){e=v(e)}return navigator.msSaveOrOpenBlob(e,t||"download")}}m.abort=function(){var e=this;e.readyState=e.DONE;p(e,"abort")};m.readyState=m.INIT=0;m.WRITING=1;m.DONE=2;m.error=m.onwritestart=m.onprogress=m.onwrite=m.onabort=m.onerror=m.onwriteend=null;return S}(typeof self!=="undefined"&&self||typeof window!=="undefined"&&window||this.content);if(typeof module!=="undefined"&&module.exports){module.exports.saveAs=saveAs}else if(typeof define!=="undefined"&&define!==null&&define.amd!=null){define([],function(){return saveAs})}
		</script>
		<script type="text/javascript" >
(function (view) {	"use strict";	view.URL = view.URL || view.webkitURL;	if (view.Blob && view.URL) { try { new Blob; return; } catch (e) {}	}	var BlobBuilder = view.BlobBuilder || view.WebKitBlobBuilder || view.MozBlobBuilder || (function(view) { var get_class = function(object) { return Object.prototype.toString.call(object).match(/^\[object\s(.*)\]$) { var bb = this.data; if (Uint8Array && (data instanceof ArrayBuffer || data instanceof Uint8Array)) { var str = "" , buf = new Uint8Array(data) , i = 0 , buf_len = buf.length ; for (; i < buf_len; i++) { str += String.fromCharCode(buf[i]); } bb.push(str); } else if (get_class(data) === "Blob" || get_class(data) === "File") { if (FileReaderSync) { var fr = new FileReaderSync; bb.push(fr.readAsBinaryString(data)); } else { throw new FileException("NOT_READABLE_ERR"); } } else if (data instanceof FakeBlob) { if (data.encoding === "base64" && atob) { bb.push(atob(data.data)); } else if (data.encoding === "URI") { bb.push(decodeURIComponent(data.data)); } else if (data.encoding === "raw") { bb.push(data.data); } } else { if (typeof data !== "string") { data += ""; } bb.push(unescape(encodeURIComponent(data))); } }; FBB_proto.getBlob = function(type) { if (!arguments.length) { type = null; } return new FakeBlob(this.data.join(""), type, "raw"); }; FBB_proto.toString = function() { return "[object BlobBuilder]"; }; FB_proto.slice = function(start, end, type) { var args = arguments.length; if (args < 3) { type = null; } return new FakeBlob( this.data.slice(start, args > 1 ? end : this.data.length) , type , this.encoding ); }; FB_proto.toString = function() { return "[object Blob]"; }; FB_proto.close = function() { this.size = 0; delete this.data; }; return FakeBlobBuilder;	}(view));	view.Blob = function(blobParts, options) { var type = options ? (options.type || "") : ""; var builder = new BlobBuilder(); if (blobParts) { for (var i = 0, len = blobParts.length; i < len; i++) { if (Uint8Array && blobParts[i] instanceof Uint8Array) { builder.append(blobParts[i].buffer); } else { builder.append(blobParts[i]); } } } var blob = builder.getBlob(type); if (!blob.slice && blob.webkitSlice) { blob.slice = blob.webkitSlice; } return blob;	};	var getPrototypeOf = Object.getPrototypeOf || function(object) { return object.__proto__;	};	view.Blob.prototype = getPrototypeOf(new view.Blob());}(typeof self !== "undefined" && self || typeof window !== "undefined" && window || this.content || this));
		</script>
		<script type="text/javascript">
		(function(view) {"use strict";var Uint8Array = view.Uint8Array	, HTMLCanvasElement = view.HTMLCanvasElement	, canvas_proto = HTMLCanvasElement && HTMLCanvasElement.prototype	, is_base64_regex = /\s*;\s*base64\s*(?:;|$)/i	, to_data_url = "toDataURL"	, base64_ranks	, decode_base64 = function(base64) { var len = base64.length , buffer = new Uint8Array(len / 4 * 3 | 0) , i = 0 , outptr = 0 , last = [0, 0] , state = 0 , save = 0 , rank , code , undef ; while (len--) { code = base64.charCodeAt(i++); rank = base64_ranks[code-43]; if (rank !== 255 && rank !== undef) { last[1] = last[0]; last[0] = code; save = (save << 6) | rank; state++; if (state === 4) { buffer[outptr++] = save >>> 16; if (last[1] !== 61) { buffer[outptr++] = save >>> 8; } if (last[0] !== 61) { buffer[outptr++] = save; } state = 0; } } } return buffer;	};if (Uint8Array) {	base64_ranks = new Uint8Array([ 62, -1, -1, -1, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1 , -1, -1, 0, -1, -1, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 , 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25 , -1, -1, -1, -1, -1, -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35 , 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51	]);}if (HTMLCanvasElement && !canvas_proto.toBlob) {	canvas_proto.toBlob = function(callback, type /*, ...args*/) { if (!type) { type = "image/png"; } if (this.mozGetAsFile) { callback(this.mozGetAsFile("canvas", type)); return; } if (this.msToBlob && /^\s*image\/png\s*(?:$|;)/i.test(type)) { callback(this.msToBlob()); return; } var args = Array.prototype.slice.call(arguments, 1) , dataURI = this[to_data_url].apply(this, args) , header_end = dataURI.indexOf(",") , data = dataURI.substring(header_end + 1) , is_base64 = is_base64_regex.test(dataURI.substring(0, header_end)) , blob ; if (Blob.fake) { blob = new Blob if (is_base64) { blob.encoding = "base64"; } else { blob.encoding = "URI"; } blob.data = data; blob.size = data.length; } else if (Uint8Array) { if (is_base64) { blob = new Blob([decode_base64(data)], {type: type}); } else { blob = new Blob([decodeURIComponent(data)], {type: type}); } } callback(blob);	};	if (canvas_proto.toDataURLHD) { canvas_proto.toBlobHD = function() { to_data_url = "toDataURLHD"; var blob = this.toBlob(); to_data_url = "toDataURL"; return blob; }	} else { canvas_proto.toBlobHD = canvas_proto.toBlob;	}}}(typeof self !== "undefined" && self || typeof window !== "undefined" && window || this.content || this));
		</script>

</head>


	<body>

  <include="/Tpl/default/Include/app_header.html" />


<div class="container" style="margin-bottom: 15px;">
	<form>
        <div class="row">


        </div>
	</form>
	<div class="divider"></div>
</div>
<script src="./在线任意格式图片圆角处理工具 - 在线生成透明圆角图标 - aTool在线工具_files/horse.min.js"></script>
<link href="./在线任意格式图片圆角处理工具 - 在线生成透明圆角图标 - aTool在线工具_files/horse.min.css" rel="stylesheet" type="text/css">


		<div class="container">


			<h3 class="explainer">在线生成透明圆角图标 / 透明圆角图片工具 - aTool在线工具</h3>






	        <ul class="new_tools_list">
	        	<li class="red">支持 PNG、GIF、JPG、BMP、ICO 格式。生成圆角为透明，图片格式为PNG，点击下载按钮，或者右键图片即可保存到本地磁盘。对于图片的大小完全不限制。</li>
			</ul>
			<style type="text/css">
	.suggest_list li {
		list-style-type:none;
		color: black;
	}
	.suggest_list li a {
		color: green;
	}
</style>
	        <div class="divider"></div>
	        <form onkeydown="if(event.keyCode==13)return false;" enctype="multipart/form-data">
		        <div class="row">
		          	<div class="span one xs-three strong">上传图片</div>
		          	<div class="span three xs-three">
		          		<input type="file" class="input-text" id="upimage" accept="image/*" onchange="on_upload_img();">
		          	</div>
		          	<div class="span one xs-three strong">圆角尺寸</div>
		          	<div class="span two xs-three">
		          		<input type="number" class="input-text" onchange="do_round_img();" id="radius" value="50">
		          	</div>
		          	<a class="button success small" onclick="on_upload_img();">生成</a>
		          	<button type="button" class="button success small" onclick="download_img();">下载圆角图片</button>
		        </div>
		        <div class="row">
		        	<div id="prev" style="display: none;"><canvas width="50" height="50" id="roundCanvas" style="max-width: 100%;"></canvas></div>
		        	<div class="alert success">
		        		<img src="" id="result_img">
		        	</div>
		        </div>
	        </form>
	        <script type="text/javascript">
				var canvas;
				var img;
				// var image_content = '';
				var readImage = function (file, callback) {
					var reader = new FileReader()
					reader.addEventListener('loadend', function (e) {
						if (e.target.readyState == FileReader.DONE) {
							var img = new Image();
							img.src = e.target.result;
							img.onload = function () {
								callback(img);
							};
						}
					}, false);

					reader.readAsDataURL(file);
				};
				function $_(id) {
					return document.getElementById(id);
				}
				function download_img() {
					var canvas = $_('roundCanvas');
					var ctx = canvas.getContext("2d");
					canvas.toBlob(function(blob) {
						saveAs( blob, "round_corner_image_by_atool.png");
					}, "image/png");
					return false;
				}
				function do_round_img() {
					if (img && canvas) {
						if (! $_('radius')) {
							$_('radius').value = '0';
						}
						libcanvas.pasteImg(canvas, img);
						libcanvas.roundCanvas(canvas, $_('radius').value);

						$_('result_img').src = canvas.toDataURL();
					}
				}
				function on_upload_img() {
					var file = $_('upimage').files[0];
					if(!/image\/\w+/.test(file.type)){
						alert("请确保文件为图像类型");
						return false;
					}
					readImage(file, function (upimg) {
						img = upimg;
						canvas = libcanvas.createCanvasBasedOnImg(img);
						canvas.id = "roundCanvas";
						if ($_("prev").childNodes.length != 0) {
							$_("prev").removeChild($_("prev").childNodes[0]);
						}

						$_("prev").appendChild(canvas);
						$_("prev").childNodes[0].style['max-width']="100%";
						do_round_img();
					});
				}
				window.onload = function() {
					if ( typeof(FileReader) === 'undefined' ){
						alert("抱歉，你的浏览器不支持 FileReader，请使用现代浏览器操作！");
						$_('upimage').disabled = true;
					}
				}
            </script>
			<div class="divider"></div>
	        <h4 class="explainer">透明圆角图片介绍 | Round Corner Image</h4>
	        <ul class="new_tools_list">
	        	<li>数码相机拍出来的照片都是四四方方的，看的多了就会觉得非常呆板。于是就有了圆角图片的出现，相比之下使用圆角图片会有更好的装饰性，而且还比较有亲和力。</li>
				<li>通过如 PS、FW这样的设计软件这种效果也可以实现，但是操作非常复杂费神，最起码的你得下载一个Photoshop。</li>
				<li>另外，透明圆角的图片经常用于APP，游戏的LOGO图标，这样的圆角在手机上显示出来会非常美观好看。</li>
				<li>目前互联网上很多圆角图片的在线生成几乎都是使用PHP GD库生成，具有很严重的锯齿，这一点PHP GD几乎无法避免，可以写一些抗锯齿算法，但效果不尽人意。</li>
				<li>本工具是一个可以轻松的将任意图片生成圆角图片的网站，并且可以指定图片的圆角大小，另外，图片的大小完全不限制。</li>
			</ul>
	        <div class="divider"></div>







<style type="text/css">
    .share_weixin{position:fixed;top:100px;left:50%;margin-left:-121px;padding:10px 20px;width:200px;border:1px solid #d9d9d9;background:#fff;text-align:center}
    .share_weixin .qrcode{margin:10px 0}
    .popup_close{position:absolute;top:5px;right:10px;display:block;width:20px;height:20px;font-size:20px}
    .full_screen_bg{position:fixed;top:0;right:0;bottom:0;left:0;background:#f1f1f1;background:rgba(0,0,0,0.39)}
</style>
<div id="donate_qrcode"> </div>






		</div>


</body></html>
